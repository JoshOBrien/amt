---
title: "Simulate movement and space use with `amt`"
author: "Johannes Signer"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Simulate movement and space use with `amt`}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

## Dispersal kernel

The **dispersal kernel** is the basis for all simulations that are implemented in `amt`. The dispersal kernel consists of a habitat independent movement kernel, a habitat kernel and possible interactions between habitat and movement. The `amt` implementation combines the movement kernel and habitat kernel within the selection function of an *integrated Step Selection Function* (see Avgar et al. 2016, Signer et al. *in preparation*). The dispersal kernel needs to be updated at each time step to allow the animal to react to a spatially and temporally changing environment.

This formulation comes with the advantage that the model can be easily parameterized by fitting an iSSA to observed movement data. But it is also possible to build a dispersal kernel from scratch and use this for simulations.

### Dispersal kernel from scratch

#### Only movement (movement kernel)

```{r}
library(amt)
```

We start with the simplest dispersal kernel possible. This is a kernel that solely depends on the step-length distribution of the animal. We use a Gamma distribution here with parameters shape $k = 2$ and scale $\theta = 10$. 

```{r}
curve(dgamma(x, scale = 10, shape = 2), from = 0, to = 200, 
      ylab = "Density", xlab = "sl_")
```

Next, we have to translate the parameters of the step-length distribution to the selection function of the iSSA. There are function in `amt` to do this. The scale parameter is linked to the step length and and the shape parameter is linked to the log of the step length (see also Avgar et al. 2016 for details).

```{r}
library(amt)
devtools::load_all()
scale_to_sl(10)
shape_to_log_sl(2)
```

The last parameter that we need for calculating a dispersal kernel is a truncation distance. This is the maximum distance that is allowed by the dispersal kernel and we need this for computational reasons. An easy way to obtain this distance, is to just calculate the 95% or 99% quantile of the step-length distribution. Here we use the 99% quantile. 


```{r}
(max_dist <- qgamma(0.99, scale = 10, shape = 2))
```

With this we have all the important pieces together. The only information that is missing is a template for the landscape. We need this **even** if no spatial covariates are included because the dispersal kernel is sptially explicit on a landscape. The argument `spatial.covars` expects a raster stack (see also `?raster::stack`) with the resolution and with a (partially) overlapping extent of the dispersal kernel.

```{r}
# Create the extend and resolution of a raster
r <- raster(xmn = 0, xmx = 1e3, ymn = 0, ymx = 1e3, res = 1)
# Assign all cells a value of 1
r[] <- 1
# Create a raster stack
G <- raster::stack(r)
```

Now we can calculate a dispersal kernel using the function `dispersal_kernel()`.

```{r}
dk1 <- dispersal_kernel(
  # This is the selection function
  wx = ~ sl_ + log_sl_, 
  # We have to provide values for the coefficients 
  coefficients = c("sl_" = -0.1, "log_sl_" = 1), 
  # The template for space
  spatial.covars = G, 
  # Give the center of the dispersal kernel
  start = c(500, 500), 
  # Maximum dispersal distance
  max.dist = 67,
  # Should a raster layer be returned?
  return.raster = TRUE)
```

```{r}
raster::plot(dk1)
```

Lets use the same dispersal kernel, but shift it towards the edge of the landscape.
This lead to truncation of the dispersal kernel. 


```{r}
dk2 <- dispersal_kernel(
  ~ sl_ + log_sl_, 
  coefficients = c("sl_" = -0.1, "log_sl_" = 1), 
  spatial.covars = G, start = c(950, 980), 
  return.raster = TRUE, max.dist = 67)
raster::plot(dk2)
```


As a next step we can add directional persistence to the dispersal kernel using a von Mises distribution.
The von Mises distribution is a circular distribution that allows to model directions. 
We will start with a concentration parameter $\kappa = 1$ (0 would indicate a uniform distribution). 

```{r}
library(circular)
curve(dvonmises(x, mu = 0, kappa = 1), from = -pi, to = pi)
```

We can add an additional term to the selection function: the cosine of the turn angle, which introduces directionality. 
Hence, we have to translate the parameter $\kappa$ from the von Mises distribution into the a coefficient for the cosine of the turn angle (the function `kappa_to_cos_ta()`) does this.

```{r}
kappa_to_cos_ta(1)
```

Now we only have to adjust the arguments `wx` by adding `cos_ta_` and giving a coefficient value to for `cos_ta_`.
Everything else remains unchanged. 


```{r}
dk3 <- dispersal_kernel(
  wx = ~ sl_ + log_sl_ + cos_ta_, 
  coefficients = c("sl_" = -0.1, "log_sl_" = 1, "cos_ta_" = 2), 
  spatial.covars = G, start = c(200, 200), 
  return.raster = TRUE, max.dist = 67)
raster::plot(dk3)
```

By default the direction of the dispersal kernel is 0 (north). 
This can be controlled with the argument `direction`. 
The direction should always be given in radiant. 

```{r}
dk5 <- dispersal_kernel(
  ~ sl_ + log_sl_ + cos_ta_, 
  coefficients = c("sl_" = -0.1, "log_sl_" = 1, "cos_ta_" = 1), 
  spatial.covars = G, start = c(200, 200), 
  return.raster = TRUE, max.dist = 67, direction = pi/2)
raster::plot(dk5)
```

#### Only habtiat (habitat kernel)

Let us now turn to a dispersal kernel without movement (i.e., it is purely goverend by habitat and a maximum distance). For this we simulate two landscapes. 

```{r}
G1 <- r
G1[, 1:500] <- 0

raster::plot(G1)

# Lets create again a raster stack
G1 <- raster::stack(G1)
names(G1) <- c("hab1")
```

Now we can simulate again a dispersal kernel independent of movement. 

```{r}
dk6 <- dispersal_kernel(
  ~ hab1_end,
  coefficients = c("hab1_end" = -0.8), 
  spatial.covars = G1, start = c(500, 500), 
  return.raster = TRUE, max.dist = 67, direction = pi/2)
raster::plot(dk6)
```


We can add interaction between habitat covariates and non-spatial covariates (for example time of the day). 


```{r}
other <- tibble(day = 0:1)
dk6a <- dispersal_kernel(
  ~ hab1_end + hab1_end:day,
  coefficients = c("hab1_end" = 0.8, "hab1_end:day" = -0.8), 
  spatial.covars = G1, start = c(500, 500), 
  return.raster = TRUE, max.dist = 67, temporal.covars = other[1, ])
raster::plot(dk6a)
```

The same dispersal kernel for the same position in space, but for the night. 
```{r}
dk6b <- dispersal_kernel(
  ~ hab1_end + hab1_end:day,
  coefficients = c("hab1_end" = 0.8, "hab1_end:day" = -0.8), 
  spatial.covars = G1, start = c(500, 500), 
  return.raster = TRUE, max.dist = 67, temporal.covars = other[2, ])
raster::plot(dk6b)

```

#### Movement and habitat

In a next step with the goal to make the dispersal kernel more realistic, we can add movement to the habitat selection (as illustrated before). 

```{r}
dk7 <- dispersal_kernel(
  ~ sl_ + log_sl_ + cos_ta_ + hab1_end, 
  coefficients = c("sl_" = -0.1, "log_sl_" = 1, "cos_ta_" = 2, "hab1_end" = 1), 
  spatial.covars = G1, start = c(500, 500), 
  return.raster = TRUE, max.dist = 67)
raster::plot(dk7)
```
We can now even add an interaction between movement and habitat selection. For example the directional persistence now depends on the habitat at the center of the dispersal kernel. 

```{r}
dk8 <- dispersal_kernel(
  ~ sl_ + log_sl_ + cos_ta_ + hab1_end + cos_ta_:hab1_start, 
  coefficients = c("sl_" = -0.1, "log_sl_" = 1, "cos_ta_" = 2, 
                   "hab1_end" = 0.5, "cos_ta_:hab1_start" = -2), 
  spatial.covars = G1, start = c(400, 400), 
  return.raster = TRUE, max.dist = 67)
raster::plot(dk8)
```

Exactly the same dispersal kernel, but at a different start position.

```{r}
dk9 <- dispersal_kernel(
  ~ sl_ + log_sl_ + cos_ta_ + hab1_end + cos_ta_:hab1_start, 
  coefficients = c("sl_" = -0.1, "log_sl_" = 1, "cos_ta_" = 2, 
                   "hab1_end" = 0.5, "cos_ta_:hab1_start" = -2), 
  spatial.covars = G1, start = c(600, 600), 
  return.raster = TRUE, max.dist = 67)
raster::plot(dk9)
```




#### How long does it take

```{r}
library(tidyverse)

res <- map(c(0.5, 1, 5, 10, 20, 50), ~ {
  lscp1 <- raster(xmn = 0, xmx = 1e3, ymn = 0, ymx = 1e3, res = .)
  lscp1[] <- 1
  lscp <- raster::stack(lscp1)
  names(lscp) <- "hab1"
  
  system.time(
    dk1 <- dispersal_kernel(
      ~ sl_ + log_sl_ + hab1_end, 
      coefficients = c(sl_ = -0.1, "log_sl_" = 1, "hab1_end" = 2), 
      spatial.covars = lscp, start = c(500, 500), 
      return.raster = TRUE, max.dist = 100)
  )
})

tibble(
  x = 1e4 / c(0.5, 1, 5, 10, 20, 50)^2, 
  y = map_dbl(res, "elapsed")
) %>% ggplot(aes(x, y)) + geom_point() +
  scale_x_continuous(trans = "log10") +
  labs(x = "No cells in dispersal kernel", y = "Time [s]")
```


## Simulate a trajectory

The next step is to simulate many dispersal kernels and sample a location where the animal is at the next time step from each dispersal kernel. 
The function `simulate_track()` is doing exactly this. 

```{r}
res1 <- simulate_track(
  ~ sl_ + log_sl_ + cos_ta_, 
  coefficients = c("sl_" = -0.1, "log_sl_" = 1, "cos_ta_" = 10),
  spatial.covars = G, start = c(100, 100), 
  n = 20, direction = pi/4) 

plot(res1, type = "l")
```

```{r}

system.time(
  res1 <- map(1:200, ~ {
    simulate_track(
      ~ sl_ + log_sl_ + cos_ta_ + cos_ta_:hab2_start, 
      coefficients = c("sl_" = -0.1, "log_sl_" = 1, "cos_ta_" = 10, "hab2_end" = 1, 
                       "cos_ta_:hab2_start" = -10), 
      spatial.covars = lscp, start = c(100, 100), n = 20, direction = pi/4) %>% 
      mutate(rep = .x, t = 1:nrow(.))}) 
)

```


## Simulate a transient utilization distribution (TUD)

## Simulate a steady state utilization distribution (SSUD)

## Real data

```{r}
data(deer)
data(sh_forest)
```


```{r}
forest <- sh_forest == 1
```

Fit a step selection function

```{r}
ssf_data <- deer %>%
  steps_by_burst() %>%
  random_steps(n = 15) %>%
  extract_covariates(forest) %>%
  mutate(cos_ta = cos(ta_),
         log_sl = log(sl_))

m2 <- ssf_data %>%
  fit_clogit(case_ ~ layer + cos_ta + sl_ + layer:sl_ + 
               strata(step_id_))

summary(m2)
```

Lets get the coefficients for simulating a dispersal kernel

```{r}
sim_coef <- c(
  "layer_end" = unname(coef(m2)["layer"]),
  "log_sl_" = unname(shape_to_log_sl(sl_distr_params(m2)$shape)), 
  "sl_" = unname(scale_to_sl(sl_distr_params(m2)$scale) + coef(m2)["sl_"]), 
  "layer_end:sl_" = unname(coef(m2)["layer:sl_"]), 
  "cos_ta_" = unname(kappa_to_cos_ta(ta_distr_params(m2)$kappa) + coef(m2)["cos_ta"]))
```

Dispersal kernel at position two. 

```{r, eval = FALSE}
# from position 2
dk_p2 <- dispersal_kernel(
  ~ layer_end + cos_ta_ + sl_ + log_sl_ + layer_end:sl_, 
  coefficients = sim_coef, 
  spatial.covars = stack(forest), start = c(deer$x_[2], deer$y_[2]), 
  return.raster = TRUE, 
  max.dist = ceiling(qgamma(0.99, shape = sl_distr_params(m2)$shape, 
                    scale = sl_distr_params(m2)$scale)))
plot(dk_p2)

trk1 <- simulate_track(
  ~ layer_end + cos_ta_ + sl_ + log_sl_ + layer_end:sl_, 
  coefficients = sim_coef, 
  spatial.covars = stack(forest), start = c(deer$x_[2], deer$y_[2]), 
  max.dist = ceiling(qgamma(0.95, shape = sl_distr_params(m2)$shape, 
                    scale = sl_distr_params(m2)$scale)), 
  n = 100
)

#' Plot the track
trk1 %>% 
  ggplot(aes(x_, y_)) + geom_path() + 
  geom_point(x = deer$x_[2], y = deer$y_[2], col = "red") +
  coord_equal()

# Simulate 20 tracks
trks <- map(1:20, ~ {
  simulate_track(
    ~ layer_end + cos_ta_ + sl_ + log_sl_ + layer_end:sl_, 
    coefficients = sim_coef, 
    spatial.covars = stack(forest), start = c(deer$x_[2], deer$y_[2]), 
    direction = pi/4, 
    max.dist = ceiling(qgamma(0.95, shape = sl_distr_params(m2)$shape, 
                              scale = sl_distr_params(m2)$scale)), 
    n = 100
  ) %>% mutate(rep = .x)
}
)

#' The individual paths
trks %>% bind_rows() %>% 
  ggplot(aes(x_, y_, group = rep)) + geom_path(alpha = 0.1) +
  geom_point(x = deer$x_[2], y = deer$y_[2], col = "red") +
  coord_equal()
```


## Session

```{r}
sessioninfo::session_info()
```


